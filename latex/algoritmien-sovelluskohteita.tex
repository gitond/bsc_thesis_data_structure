\chapter{Algoritmien sovelluskohteita} \label{algoritmienSovelluskohteita}

\section{Videopelit}\label{videopelit}
Monet nykyaikaiset polunetsintäalgoritmeihin liittyvät tutkimukset tehdään 
videopeliteollisuuden 
käyttöön.\cite{MathewAndMalathy}\cite{ACMHindawi}\cite{mazeGameTrilogi} 
Tämä johtuu siitä, että videopeleissä törmätään usein tilanteisiin, jossa 
NPC-hahmojen pitää liikkua videopelikartalla niin, että pelaaja ei suoraan 
itse ohjaa niitä. Tällöin pelin on itse löydettävä reitti kahden pisteen 
välille. Kun polunetsintäalgoritmeja toteutetaan videopeleissä, joudutaan 
kiinnittämään huomiota muutamiin erityisvaatimuksiin. Polunetsintäalgoritmien 
ajaminen ei saa olla liian resurssi-intensiivistä, eli sen pitää pyrkiä 
kuluttamaan tietokoneen muistia ja suoritinaikaa mahdollisimman vähän. Jotta 
resurssi-intensiivisyydeltä vältyttäisiin, voidaan löystää polun 
optimaalisuuteen liittyviä vaatimuksia, jolloin polun ei tarvitse olla enää 
lyhin mahdollinen.\cite{MathewAndMalathy} \par
	Esimerkiksi reaaliaikaisissa strategiapeleissä (real-time strategy, 
RTS) pelaaja komentaa usein eri yksiköitä eri puolelle pelialuetta 
mekitsemällä niille maalipisteitä. Näitä yksiköitä voi olla jopa satoja, 
joille pitää löytää polut suurella etsintä-alueella huomioiden mahdollisesti 
muut alueella liikkuvat yksiköt, sekä pelin säännöt siitä, että miten eri 
yksiköt käytännössä voivat liikkua.\cite{pPacman}\cite{MathewAndMalathy} 
Nämä monimutkaiset laskutoimitukset on suoritettava pelin logiikan 
vaatimalla nopeudella. Esimerkiksi videopeliyhtiö BioWare on asettanut 
säännön, jonka mukaan kaikkien pelialueella liikkuvien agenttien polunetsintä 
on kyttävä suorittamaan 1-3 ms aikana.\cite{pPacman} \par
	\textcite{pPacman} kehittivät Pathfinding-in-Pacman-projektin, jossa 
he sovelsivat polunetsintäalgoritmeja Pac-Manin kaltaiseen peliin. Pelissä 
pelihahmo liikkuu labyrintissä yrittäen kerätä pisteitä, samalla kun sitä 
jahtaavat vihollishahmoina toimivat haamut. Pelaaja voittaa kerättyään kaikki 
pisteet, ja häviää kun haamut koskevat häntä. Peli sisältää toteutukset BFS- 
ja A*-algoritmeista, sekä pelin tarkoituksiin muokatusta A*-algoritmistä, 
jota projektin raportti kutsuu Context Dependent Subgoaling A*-algoritmiksi
(kontekstiriippuvaisesti osatavoitteistava A*, CDSA*) ja ohjelmakoodi kutsuu 
subGoalAStar-algoritmiksi. CSDA* etsii polun haamulta pelaajahahmolle 
A*-algoritmilla, mikäli haamu on tarpeeksi lähellä pelaajahahmoa. Muussa 
tapauksessa CSDA* palauttaa ainoastaan suunnan, jolla haamu pääsee lähemmäs 
pelaajahahmoa. Tällä tavoin säästetään järjestelmän resursseja rajoittamalla 
tehtävien laskujen määrää. Pelissä käytetään polunetsintäalgoritmeja 
haamujen ja pelaajahahmojen välisen polun löytämiseksi ja A*- ja 
CSDA*-algoritmit käyttävät heuristiikkana Manhattan-etäisyyttä. \par
	\textcite{SturtevantDAO} vertaavat tutkimuksessaan erilaisia 
suurelle etsintäalueelle soveltuvia polunetsintätekniikoita Dragon Age: 
Origins-videopelissä (DAO) käytettyyn polunetsintään. Nämä 
polunetsintätekniikat ovat abstraktiahierarkien käyttö, parempien 
heurististen funktioiden käyttö, sekä sopimushierarkioiden (Contrarction 
Hierarchy, CH) käyttö. Abstraktihierarkia ja CH ovat hierarkisessa 
polunetsinnässä (luku \ref{hpa}) käytettäviä tapoja muodostaa ylätason 
graafi. Abstraktihierarkia muodostaa ylätason graafin niin, että 
varsinaisen etsintäalueen eri osa-alueet ovat ylätason graafin solmuja, kun 
taas CH muodostaa ylätason graafin laskemalla alkuperäisen graafin jokaiselle 
solmulle tärkeystason (importance level) ja poistamalla vähemmän tärkeät 
solmut graafista. \textcite{SturtevantDAO} osoittivat, että hierarkinen 
polunetsintä joko abstraktiohierarkiaa tai CH:ta käyttäen soveltui parhaiten 
polunetsintään DAO:n kaltaisissa videopeleissä, koska näillä menetelmillä 
käytettiin vähiten suoritinta ja muistia. DAO käyttää abstraktiohierarkiaa, 
mutta \textcite{SturtevantDAO} mainitsevat, että pelin polunetsintää olisi 
voinut tehostaa entisestään käyttämällä suurempia osa-alueita ylätason 
graafin rakentamiseen.

\section{Karttaohjelmat}\label{karttaohjelmat}
Polunetsintäalgoritmit ovat myös keskeisessä osassa karttaohjelmistoissa. 
Monet karttaohjelmat tarjoavat reitinhakupalveluita, joissa generoidaan kartan  
eri pisteiden välille reitti käyttäen polunetsintäalgoritmeja. Tämä on usein 
helppo toteuttaa, koska karttaohjelmat säilyttävät karttadataa usein 
polunetsintäalgoritmeille ideaalisessa muodossa. Esimerkiksi OpenDrive-
formaatti sisältää dataa risteyksistä ja teistä, josta kootaan 
reititysgraafi.\cite{Lanelet2} \par
	\textcite{OpenStreetMap} on yhteisön ylläpitämä avoimen lähdekoodin 
karttatietokanta, joka tarjoaa sivustollaan myös tietokannan karttadataa 
käyttävää karttaohjelmaa.\cite{OSMAbout} OpenStreetMap-karttaohjelma sisältää 
myös reitinhakumahdollisuuden. Reitinhakumahdollisuus sisältää 
reitinhakuvaihtoehdot kävelylle, pyöräilylle ja autoilulle käyttäen joko 
GraphHopperia, OSRM:ää tai Valhallaa.\cite{OpenStreetMap} \par
	Nämä ovat niin sanottuja reititysmoottoreita (routing engine), jotka 
ovat valmiita ohjelmistototeutuksia polunetsintäfunktioille.\cite{graphhopper} 
OpenStreetMapin käyttämä \textcite{graphhopper} on Javalla kirjoitettu 
reititysmoottori. Se käyttää sisäisessä toteutuksessaan Dijkstran algoritmia, 
A*-algoritmia, sekä hierarkista polunetsintää käyttäen CH-menetelmää ylätason 
graafin luomiseen ja Dijkstran algoritmiä polunetsintään. GraphHopper valitsee 
ongelmaan sopivan polunetsintämenetelmän sen asetusten perusteella.

\section{Robotiikka}\label{robotiikka}
